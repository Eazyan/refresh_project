# Курс восстановления навыков разработки: от простого к комплексному

## Общая концепция
Создание единого приложения "Система управления задачами" (Task Management System), которое постепенно усложняется от простого HTML до полноценного микросервисного решения.

## Стек технологий
- **Frontend**: React 18 + Vite + TypeScript
- **Backend**: Node.js + Express + TypeScript (основной) + Python + FastAPI (альтернативный)
- **База данных**: PostgreSQL + Prisma ORM (Node.js) / SQLAlchemy (Python)
- **Кэширование**: Redis
- **Стриминг/Очереди**: Apache Kafka + Kafka Streams
- **Дополнительно**: JWT, Docker, Nginx, RabbitMQ (для сравнения)

---

## Модуль 1: Основы Frontend (Неделя 1-2)

### Урок 1.1: Настройка окружения и первый компонент
**Цель**: Восстановить базовые навыки работы с React и Vite
**Задача**: Создать простую страницу со списком задач

**Что делаем**:
- Инициализация проекта: `npm create vite@latest task-manager --template react-ts`
- Создание компонента TaskList с хардкодными данными
- Базовая стилизация через CSS модули

**Результат**: Статическая страница с 3-5 задачами в виде карточек

### Урок 1.2: Состояние и события
**Цель**: Вспомнить работу с useState и обработчиками событий
**Задача**: Добавить возможность создания и удаления задач

**Что делаем**:
- useState для массива задач
- Форма добавления новой задачи
- Кнопки удаления задач
- Валидация формы

**Результат**: Интерактивный список задач (CRUD операции в памяти)

### Урок 1.3: Компонентная архитектура
**Цель**: Разбить приложение на логические компоненты
**Задача**: Рефакторинг в компонентную структуру

**Что делаем**:
- TaskItem, TaskList, TaskForm, TaskFilter как отдельные компоненты
- Props и типизация TypeScript
- Подъём состояния вверх

**Результат**: Чистая архитектура с переиспользуемыми компонентами

---

## Модуль 2: Продвинутый Frontend (Неделя 3-4)

### Урок 2.1: Стилизация и анимации
**Цель**: Создать приятный пользовательский интерфейс
**Задача**: Добавить современные стили и анимации

**Что делаем**:
- CSS Grid/Flexbox для layout
- CSS переходы и анимации (появление/исчезновение задач)
- Hover эффекты, focus states
- Responsive дизайн

**Результат**: Красивое, анимированное приложение

### Урок 2.2: Продвинутое состояние
**Цель**: Изучить useReducer и Context API
**Задача**: Централизованное управление состоянием

**Что делаем**:
- useReducer для сложной логики состояния
- Context для передачи данных между компонентами
- Custom hooks для бизнес-логики

**Результат**: Масштабируемая архитектура состояния

### Урок 2.3: Роутинг и навигация
**Цель**: Многостраничное приложение
**Задача**: Добавить страницы и навигацию

**Что делаем**:
- React Router: страницы "Все задачи", "Выполненные", "Профиль"
- Навигационное меню
- Защищённые роуты (подготовка к авторизации)

**Результат**: SPA с навигацией между страницами

---

## Модуль 3: Backend и База данных (Неделя 5-6)

### Урок 3.1: Node.js Express сервер
**Цель**: Создать REST API сервер на Node.js
**Задача**: Базовый Express + TypeScript сервер с маршрутизацией

**Что делаем**:
- Инициализация Express + TypeScript проекта
- Роуты для CRUD операций с задачами
- Middleware для логирования и CORS
- Валидация данных через Joi или Zod
- Автоматическая типизация с TypeScript

**Результат**: REST API с эндпоинтами /api/tasks

### Урок 3.2: PostgreSQL и Prisma ORM
**Цель**: Подключить реляционную базу данных
**Задача**: Сохранение задач в PostgreSQL

**Что делаем**:
- Установка PostgreSQL (Docker или локально)
- Настройка Prisma ORM с TypeScript типами
- Создание схемы Task с полями: id, title, description, completed, createdAt
- Prisma миграции и seed данные
- Prisma Client для типобезопасных запросов

**Результат**: Задачи сохраняются в реальной БД с полной типизацией

### Урок 3.3: Интеграция Frontend-Backend
**Цель**: Связать React приложение с Node.js API
**Задача**: Заменить локальное состояние на API вызовы

**Что делаем**:
- Axios для HTTP запросов к Express серверу
- useEffect для загрузки данных
- Обработка состояний загрузки и ошибок
- Оптимистичные обновления UI
- Общие TypeScript типы между фронтом и бэком

**Результат**: Полнофункциональное приложение с Node.js бэкендом

### Урок 3.4: Альтернативная реализация на Python FastAPI
**Цель**: Сравнить подходы Node.js vs Python
**Задача**: Переписать тот же API на FastAPI

**Что делаем**:
- Инициализация FastAPI проекта с Poetry
- Те же эндпоинты, но на Python
- Pydantic модели для валидации
- SQLAlchemy с async поддержкой
- Автоматическая документация Swagger
- Сравнение производительности и DX

**Результат**: Два варианта бэкенда для сравнения подходов

---

## Модуль 4: Аутентификация и авторизация (Неделя 7)

### Урок 4.1: JWT авторизация на Node.js
**Цель**: Добавить систему пользователей
**Задача**: Регистрация, вход, защищённые роуты

**Что делаем**:
- Модель User в Prisma схеме
- Эндпоинты /auth/register, /auth/login на Express
- JWT токены через jsonwebtoken библиотеку
- Middleware для проверки авторизации
- Хеширование паролей через bcryptjs
- Связь задач с пользователями (Task.userId foreign key)

**Результат**: Персональные списки задач для каждого пользователя

### Урок 4.2: Авторизация на Frontend
**Цель**: Реализовать вход/выход на клиенте
**Задача**: Формы входа/регистрации, сохранение токенов

**Что делаем**:
- Компоненты LoginForm, RegisterForm
- Context для хранения данных пользователя
- Автоматическое добавление токена к запросам (axios interceptors)
- Редирект неавторизованных пользователей
- Обработка ошибок 401/403

**Результат**: Полная система аутентификации с Node.js бэкендом

### Урок 4.3: Альтернативная авторизация на Python
**Цель**: Сравнить JWT реализации
**Задача**: Та же авторизация, но на FastAPI

**Что делаем**:
- FastAPI Dependency для проверки токенов
- python-jose для JWT операций
- passlib + bcrypt для паролей
- OAuth2PasswordBearer схема для Swagger
- Сравнение подходов Node.js vs Python

**Результат**: Два варианта авторизации для изучения

---

## Модуль 5: Кэширование с Redis (Неделя 8)

### Урок 5.1: Redis с Node.js
**Цель**: Ускорить работу приложения кэшированием
**Задача**: Кэширование частых запросов в Express

**Что делаем**:
- Установка и настройка Redis
- Подключение redis клиента к Node.js
- Middleware для кэширования GET запросов
- Кэширование списка задач пользователя на 5 минут
- Инвалидация кэша при изменениях (CREATE/UPDATE/DELETE)
- Сравнение с подходом, где эти функции могли бы быть реализованы через Kafka

**Результат**: Быстрые повторные загрузки данных в Node.js

### Урок 5.2: Продвинутое кэширование
**Цель**: Использовать Redis для сессий и сложного кэширования
**Задача**: Сохранение пользовательских сессий в Redis

**Что делаем**:
- express-session с redis-store для сессий
- Кэширование результатов сложных запросов (статистика, аггрегации)
- TTL (время жизни) для разных типов данных
- Pipeline операции для batch обновлений
- Мониторинг использования кэша через Redis CLI

**Результат**: Масштабируемая система кэширования

### Урок 5.3: Redis с Python (сравнение)
**Цель**: Сравнить подходы к кэшированию
**Задача**: Те же возможности, но в FastAPI

**Что делаем**:
- redis-py с async поддержкой
- Кэширующие декораторы для FastAPI эндпоинтов
- Сравнение производительности и удобства
- Общие паттерны кэширования

**Результат**: Понимание различий в реализации кэша

---

## Модуль 6: Event Streaming с Apache Kafka (Неделя 9-10)

### Урок 6.1: Основы Apache Kafka с Node.js
**Цель**: Изучить event-driven архитектуру
**Задача**: Настроить Kafka и первые продюсеры/консьюмеры

**Что делаем**:
- Установка Kafka через Docker (Zookeeper + Kafka broker)
- Создание топиков: task-events, user-events, notifications
- kafkajs клиент для Node.js продюсера/консьюмера
- Отправка событий создания задач из Express API
- Простой консьюмер для обработки событий
- Обсуждение сценариев, где Kafka может заменить функции Redis (кэширование, pub/sub, очереди)

**Результат**: Базовая Kafka инфраструктура с Node.js интеграцией

### Урок 6.2: Event Sourcing паттерн
**Цель**: Реализовать событийную архитектуру
**Задача**: Все изменения задач идут через события

**Что делаем**:
- Рефакторинг Express API: вместо прямого изменения БД - отправка событий
- События: TaskCreated, TaskCompleted, TaskDeleted, TaskUpdated
- Event Store в PostgreSQL для хранения всех событий
- Проекции (read models) для быстрого чтения через Prisma
- Replay событий для восстановления состояния

**Результат**: Event-driven система с полной историей изменений

### Урок 6.3: RabbitMQ для сравнения
**Цель**: Сравнить Kafka и RabbitMQ
**Задача**: Та же функциональность на RabbitMQ

**Что делаем**:
- Установка RabbitMQ
- amqplib для Node.js интеграции
- Сравнение паттернов: pub/sub, work queues, routing
- Когда использовать Kafka vs RabbitMQ
- Performance сравнение

**Результат**: Понимание различий между брокерами сообщений

### Урок 6.4: Python Kafka интеграция и FastAPI основы
**Цель**: Микросервисы на разных языках с современным Python стеком
**Задача**: Создать аналитический сервис на Python с FastAPI

**Что делаем**:
- Настройка FastAPI проекта с оптимальной структурой
- Установка и настройка uvicorn для ASGI сервера
- Интеграция с Kafka через confluent-kafka-python и aiokafka
- Analytics Service с асинхронными обработчиками
- Обработка событий из Kafka в Python с асинхронными потоками
- Swagger документация через FastAPI
- Межъязыковая коммуникация через Kafka

**Результат**: Полиглот микросервисная архитектура с Python/FastAPI сервисом

### Урок 6.5: Python интеграция с базами данных
**Цель**: Работа с различными типами баз данных из Python
**Задача**: Добавить хранение аналитических данных в БД

**Что делаем**:
- Реляционные БД через SQLAlchemy и asyncpg
- Асинхронные запросы к PostgreSQL
- Миграции с Alembic
- NoSQL через pymongo и motor (асинхронный драйвер)
- Модели данных с Pydantic
- Управление конфигурацией через pydantic-settings и python-dotenv
- Сравнение производительности разных подходов

**Результат**: Python микросервис с гибкой структурой хранения данных

### Урок 6.6: Python авторизация и безопасность
**Цель**: Создать безопасный доступ к Python микросервису
**Задача**: Внедрить авторизацию в аналитический сервис

**Что делаем**:
- JWT аутентификация с python-jose[cryptography]
- Хеширование паролей с passlib[bcrypt]
- Защита маршрутов через зависимости FastAPI
- Загрузка файлов с python-multipart
- Валидация email с email-validator
- Безопасные заголовки и CORS настройки
- Интеграция с основной системой авторизации

**Результат**: Безопасный доступ к аналитическим функциям

### Урок 6.7: Интеграция очередей в Python
**Цель**: Сравнить разные подходы к очередям в Python
**Задача**: Создать альтернативные реализации для обмена сообщениями

**Что делаем**:
- Redis как брокер через aioredis и redis
- RabbitMQ через aio-pika и pika
- Сравнение с Kafka подходом
- Сценарии использования разных брокеров
- Паттерны обмена сообщениями (pub/sub, request/reply)
- Отказоустойчивость и гарантии доставки
- Бенчмарки производительности
- Анализ случаев, когда Kafka может полностью заменить Redis/RabbitMQ, и когда лучше использовать их вместе

**Результат**: Понимание когда использовать разные брокеры сообщений

### Урок 6.8: Утилиты и расширенные возможности Python сервисов
**Цель**: Добавить продвинутую функциональность в Python микросервисы
**Задача**: Реализовать генерацию отчетов и обработку данных

**Что делаем**:
- Работа с датами и временем через pytz и tzlocal
- HTTP клиент для внешних API с requests
- Обработка и анализ данных с pandas
- Генерация Excel отчетов с xlsxwriter и openpyxl
- Работа с календарями через ics
- Транслитерация данных с transliterate
- Асинхронное выполнение тяжелых задач
- Периодические задачи по расписанию

**Результат**: Полнофункциональный аналитический сервис с отчетами

---

## Модуль 7: Микросервисы и масштабирование (Неделя 11-12)

### Урок 7.1: API Gateway и Service Discovery
**Цель**: Централизованное управление микросервисами
**Задача**: Единая точка входа для всех сервисов

**Что делаем**:
- Настройка Kong или Nginx как API Gateway
- Роутинг запросов к разным микросервисам (Node.js и Python)
- Load balancing между инстансами сервисов
- Rate limiting и authentication на уровне gateway
- Health checks для автоматического исключения неработающих сервисов
- Трассировка запросов между микросервисами

**Результат**: Централизованное управление API

### Урок 7.2: Оркестрация и мониторинг
**Цель**: Production-ready развёртывание
**Задача**: Docker Compose, логирование, мониторинг

**Что делаем**:
- Docker Compose для всей инфраструктуры (Node.js, Python, Kafka, Redis, RabbitMQ, PostgreSQL)
- Централизованное логирование через ELK stack
- Метрики через Prometheus + Grafana для мониторинга всех сервисов
- Healthcheck эндпоинты в каждом сервисе
- Graceful shutdown для корректного завершения работы
- Автоматический рестарт упавших сервисов

**Результат**: Production-ready микросервисная система

### Урок 7.3: Распределённые транзакции (Saga pattern)
**Цель**: Консистентность данных в микросервисах
**Задача**: Реализация Saga для сложных бизнес-операций

**Что делаем**:
- Saga паттерн для операций, затрагивающих несколько сервисов
- Choreography-based saga через Kafka/RabbitMQ события
- Компенсирующие действия при ошибках
- Saga state machine в отдельном сервисе
- Idempotency для обработки дублированных сообщений
- Интеграция Node.js и Python сервисов в единую бизнес-логику

**Результат**: Надёжная консистентность в распределённой системе

### Урок 7.4: Полиглот персистентность и синхронизация данных
**Цель**: Эффективное использование разных баз данных
**Задача**: Синхронизация данных между сервисами с разными БД

**Что делаем**:
- CQRS паттерн для разделения операций чтения и записи
- Event sourcing для синхронизации между PostgreSQL и MongoDB
- Материализованные представления для аналитики
- Change Data Capture (CDC) из PostgreSQL в Kafka
- Синхронизация кэша Redis с основной БД
- Стратегии консистентности данных в распределенной системе

**Результат**: Оптимальное использование разных типов хранилищ данных

---

## Модуль 8: Оптимизация и безопасность (Неделя 13)

### Урок 8.1: Безопасность Python API
**Цель**: Защитить приложение от основных угроз
**Задача**: Реализация мер безопасности в FastAPI

**Что делаем**:
- Rate limiting через slowapi (FastAPI аналог express-rate-limit)
- Валидация и санитизация через Pydantic models с custom validators
- HTTPS настройка с SSL сертификатами
- Защита от SQL инъекций (SQLAlchemy ORM безопасность)
- CORS политики настройка в FastAPI
- Input validation на уровне Kafka сообщений

**Результат**: Безопасное Python приложение

### Урок 8.2: Производительность Python/Kafka системы
**Цель**: Оптимизировать скорость работы всей системы
**Задача**: Профилирование и оптимизация

**Что делаем**:
- Профилирование FastAPI через py-spy и cProfile
- Async/await оптимизация для БД операций
- Оптимизация SQL запросов (индексы, EXPLAIN ANALYZE)
- Kafka producer/consumer настройки производительности
- Connection pooling для PostgreSQL и Redis
- Batch processing для Kafka messages
- Сжатие ответов (gzip) в FastAPI

**Результат**: Высокопроизводительная event-driven система

---

## Инструкции для AI-ассистента

### Структура проведения урока:
1. **Объявить цель урока** - что именно мы изучаем и зачем
2. **Показать код по шагам** - небольшие порции с объяснениями
3. **Дать время на самостоятельное написание** - попросить написать код самостоятельно
4. **Проверить результат** - разобрать ошибки, если есть
5. **Закрепить теорию** - объяснить концепции за кодом

### Ключевые принципы:
- **Всегда просить писать код руками** - не давать готовые решения вообще. Ко всему нужно прийти самому. Как бы пользователь не просил — только синтаксис. Это самое строгое и важное условие
- **Объяснять каждую строку** - особенно синтаксис и нюансы
- **Поощрять эксперименты** - предлагать модификации кода
- **Связывать с реальными задачами** - объяснять, где это применяется

### Если ученик застрял:
1. Дать подсказку, а не готовое решение
2. Показать аналогичный пример
3. Разбить задачу на более мелкие шаги
4. Напомнить о документации и отладке (Можно использовать поиск в интернете и давать конкретные места к прочитке. В таком случае это будет наиболее правильная помощь)

### Формат ответа AI (нужно создать .md файл с соответствующим уроком, и потом работать по нему же в чате):
```
## Урок X.Y: [Название]

**Цель**: [Что изучаем]
**Время**: [Примерная длительность]

### Теория (5-10 минут)
[Краткое объяснение концепций]

### Практика (30-40 минут)
**Задание**: [Что нужно написать]

**Шаг 1**: [Первый шаг с примером]
Попробуйте написать это самостоятельно...

**Шаг 2**: [Следующий шаг]
...

### Закрепление (10 минут)
[Вопросы для понимания]
```

---

## Дополнительные материалы по модулям

### Полезные ресурсы:
- React документация: reactjs.org
- TypeScript документация: typescriptlang.org
- Node.js документация: nodejs.org
- Express документация: expressjs.com
- Prisma документация: prisma.io
- Python документация: python.org
- FastAPI документация: fastapi.tiangolo.com
- SQLAlchemy документация: sqlalchemy.org
- PostgreSQL документация: postgresql.org
- Redis документация: redis.io
- Apache Kafka документация: kafka.apache.org
- RabbitMQ документация: rabbitmq.com
- KafkaJS документация: kafka.js.org
- Confluent Kafka Python: confluent-kafka-python.readthedocs.io

### Проверочные вопросы для каждого модуля включены в уроки





## Дополнение для ассистента:

### Изначальный запрос от пользователя при составлении этого плана:

Привет! Я делаю огромнейший проект по контролю посещаемости и успеваемости для университета. Много ролей, проект максимально серьёзного и большого уровня
И делаю я его полностью с помощью нейронных сетей, в частности тебя. Сам понимаешь, что это ужасно, ведь ты часто можешь что-то недоглядеть или галлюцинировать, а я, по не знанию, не вижу этого. К тому же, оптимизация и безопасность тоже хромает, потому что агент не успевает за всем уследить
Поэтому вот о чём я тебя прошу. Напиши мне в md формате структуру курса, где я буду учить React + VITE + RabbitMQ + PostgreSQL + Redis (Дополни, если я что-то забыл). Учти, что несмотря на все мои проблемы — я в программировании уже 10 лет, поэтому в целом всё понимаю. Важно вернуть мне навык написания кода самому, своими руками, и знание синтаксиса. Сейчас я не могу даже первые строчки написать сам, даже простенький калькулятор какой-нибудь
Нужно составить курс грамотно, чтобы я какое-то одно и то же приложение постепенно делал всё лучше и лучше. Как-бы такая песочница, на страницу стили, к ним анимации, к этому всему сервер с БД, к этому Редис для кэширования, потом Рэббит для делегирования, уведомлений и т.д.
И самое главное — сделай так, чтобы весь этот курс могла понять нейросеть. Чтобы в любой нейросети, в любом чате я мог указать на урок, и попросить его провести мне, сказать, что делать и какие темы рассказать. Так я смогу гибко уходить/приходить и продолжать работу без потерь смысла и качества
Ну а основную цель ты уже понял — вернуть мне навык писания кода вручную, это самое главное!

### Дополнительные замечания:

1. По рекомендации профессионала отмечено, что Kafka стек может функционально закрывать возможности Redis и RabbitMQ, но Redis остается в курсе для изучения и срё